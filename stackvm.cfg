// Stack Based Virtual Machine using Xonotic's builtin database and stack.
// by Jiān
// repo: https://github.com/DetectiveJian/stackvm-xonotic
//
// Suggested Reads:
// Xonotic Console Tips and tricks: https://forums.xonotic.org/showthread.php?tid=2987
// Xonotic rpn quakec source: https://gitlab.com/xonotic/xonotic-data.pk3dir/-/blob/master/qcsrc/common/command/rpn.qc
// Stack Machine on Wikipedia: https://en.wikipedia.org/wiki/Stack_machine
// Stack Based Virtual Machine written in Java: https://andreabergia.com/series/stack-based-virtual-machines/



set CLOCK_SPEED "0.001" // ~1KHz
set INSTRUCTION_POINTER "0"
set STACKVM_HALTED "0"
set STACKVM_IS_SLEEPING "0"
set STACKVM_BREAK_LINE "-1"
set FRAME_NUMBER "0"

// Frame
alias init_frame "rpn /${FRAME_NUMBER}.return_address ${INSTRUCTION_POINTER} put;"

init_frame	// setup initial frame at script execution.

// Machine Oprations
alias hlt 	"set STACKVM_HALTED 1"

// Stack Operations
alias push 	"rpn ${1} dbpush"
alias pop 	"rpn /STACKVM_LAST_POP dbpop ="
alias dup 	"rpn dbget dbpush"

// Arithmetic Operations
alias add 	"rpn dbpop dbpop exch + dbpush"
alias sub	"rpn dbpop dbpop exch - dbpush"
alias mul	"rpn dbpop dbpop exch * dbpush"
alias div	"rpn dbpop dbpop exch / dbpush"
alias pow 	"rpn dbpop dbpop exch ** dbpush"
alias mod 	"rpn dbpop dbpop exch % dbpush"
alias max	"rpn dbpop dbpop exch max dbpush"
alias min	"rpn dbpop dbpop exch min dbpush"

// Boolean Operations
alias and 	"rpn dbpop dbpop and dbpush"
alias or 	"rpn dbpop dbpop or dbpush"
// NOTE: not and bitnot operations of rpn command have a bug where
// it needs two oprands on the stack to work correctly, it will be
// fixed in the next stable release of Xonotic. Will have to remove
// the "dup" operation from the not instruction when that happens.
alias not 	"rpn dbpop dup not dbpush"

// Comparison Operations
alias iseq	"rpn dbpop dbpop exch == dbpush"
alias isgt 	"rpn dbpop dbpop exch > dbpush"
alias isge	"rpn dbpop dbpop exch >= dbpush"
alias islt	"rpn dbpop dbpop exch < dbpush"
alias isle	"rpn dbpop dbpop exch <= dbpush"
alias isne	"rpn dbpop dbpop exch != dbpush"

// JUMP Instructions
alias jmp 	"rpn /INSTRUCTION_POINTER ${1} 1 - ="
alias jif 	"rpn /__IF_TRUE__ 1 0 dbpop when =; set __JUMP_ADDRESS__ ${1}; __jump_if_true__"
alias __jump_if_true__ "__jif_${__IF_TRUE__}__"
alias __jif_0__ ""
alias __jif_1__ "jmp ${__JUMP_ADDRESS__}"

// Variable Storing and loading.
// store_l and load_l are for saving and loading local variable
// these variable have local scope, associated with the frame
alias store_l 	"rpn /${FRAME_NUMBER}.${1} dbpop put"
alias load_l	"rpn /${FRAME_NUMBER}.${1} get dbpush"

// GLobal variables
// These variables have global scope
alias store_g 	"rpn /${1} dbpop put"
alias load_g 	"rpn /${1} get dbpush"

// Function calls and return
alias call 		"rpn /FRAME_NUMBER dup load 1 + =; init_frame; jmp ${1}"
alias ret 		"rpn /__IF_RET_TRUE__ 1 0 /FRAME_NUMBER load when =; __ret_check__"
alias __ret_check__ "__ret_${__IF_RET_TRUE__}__"
alias __ret_1__ "rpn /INSTRUCTION_POINTER ${FRAME_NUMBER}.return_address get = /FRAME_NUMBER dup load 1 - =;"
alias __ret_0__ "set STACKVM_HALTED 1; echo ^7[STACKVM]: ^1Invalid return instruction [^2@ ${INSTRUCTION_POINTER}^1], frame is ^3${FRAME_NUMBER}^1...^7"


// call vector from stack - use the stack head as the pointer to a function
// used for interrupt routines
alias call_vfs "rpn /__stackvm_call_vector__ dbpop =; __call_vfs___"
alias __call_vfs___ "call ${__stackvm_call_vector__}"

// print an interger from the stack head to console.
alias dot 		"rpn /STACKVM_OUT_BUFF dbpop =; print_cvar STACKVM_OUT_BUFF"
alias print_cvar "echo ${$1}"

// StackVM CPU, main
alias s "alias ${1} \"${2-}\""


// Execute the program
alias run "__CPU_HALTED_${STACKVM_HALTED}__"

alias __CPU_HALTED_0__ "${INSTRUCTION_POINTER}; rpn /INSTRUCTION_POINTER dup load 1 + =; defer ${CLOCK_SPEED} \"__CPU_POST_EXEC__\""
alias __CPU_POST_EXEC__ "__CPU_HALTED_${STACKVM_HALTED}__"
alias __CPU_HALTED_1__ ""

// run progam with debug mode enabled
alias run_with_debug "__DEBUG_MODE_CPU_${STACKVM_HALTED}__"

alias __DEBUG_MODE_CPU_0__ "__DEBUG_MODE_EXTRA__; __DEBUG_CHECK_BREAK__; ${INSTRUCTION_POINTER}; rpn /INSTRUCTION_POINTER dup load 1 + =; defer ${CLOCK_SPEED} \"__DEBUG_MODE_CPU_POST_EXEC__\""
alias __DEBUG_MODE_CPU_POST_EXEC__ "__DEBUG_MODE_CPU_${STACKVM_HALTED}__"
alias __DEBUG_MODE_CPU_1__ "echo ^7[STACKVM]: ^2CPU halted.^7"
alias __DEBUG_MODE_EXTRA__ "echo ^7[STACKVM]: ^2executing ${INSTRUCTION_POINTER}^7"


// set breakpoint in code, to pause exectution when the INSTRUCTION_POINTER reaches that breakpoint
alias breakpoint "rpn /STACKVM_BREAK_LINE ${1} ="
alias __DEBUG_CHECK_BREAK__ "rpn /__BREAK_TRUE__ /INSTRUCTION_POINTER load /STACKVM_BREAK_LINE load 1 - == =; __DEBUG_BREAK__"
alias __DEBUG_BREAK__ "__DEBUG_BREAK_${__BREAK_TRUE__}__"
alias __DEBUG_BREAK_1__ "echo ^7[STACKVM DEBUG]: ^2reached breakpoint ${STACKVM_BREAK_LINE} stopping execution^7; hlt; defer 0.1 \"set STACKVM_HALTED 0\""
alias __DEBUG_BREAK_0__ ""


// step through the program
alias step "__CPU_STEP_${STACKVM_HALTED}__"
alias __CPU_STEP_0__ "echo ^7[STACKVM]: ^2executing ${INSTRUCTION_POINTER}^7; ${INSTRUCTION_POINTER}; rpn /INSTRUCTION_POINTER dup load 1 + =;"
alias __CPU_STEP_1__ "echo ^7[STACKVM]: ^1An halted cpu cannot execute instructions.^7"

// Reset CPU
alias reset "set INSTRUCTION_POINTER 0; set STACKVM_HALTED 0; set FRAME_NUMBER 0; set STACKVM_BREAK_LINE -1; echo ^7[STACKVM]: ^2CPU reset complete.^7"

// Make the stackvm CPU wait for some time before resuming program execution.
alias sleep "set __sleep_time__ ${1}; __SLEEP_CPU_${STACKVM_IS_SLEEPING}__"
alias __SLEEP_CPU_0__ "set STACKVM_IS_SLEEPING 1; defer ${__sleep_time__} \"set CLOCK_SPEED ${CLOCK_SPEED}; set STACKVM_IS_SLEEPING 0\"; set CLOCK_SPEED ${__sleep_time__}"
alias __SLEEP_CPU_1__ "echo ^7[STACKVM]: ^1CPU already sleeping...^7"

// MISC
alias LABLE "set ${1} ${2}"

// just to be safe, in case user forgot to add hlt instruction to their program.
s 600 hlt
